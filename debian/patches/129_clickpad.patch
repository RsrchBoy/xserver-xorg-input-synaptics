Index: xserver-xorg-input-synaptics/include/synaptics-properties.h
===================================================================
--- xserver-xorg-input-synaptics.orig/include/synaptics-properties.h	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/include/synaptics-properties.h	2012-03-02 11:50:06.235780000 -0800
@@ -49,6 +49,9 @@
 #define SYNAPTICS_PROP_TAP_DURATIONS "Synaptics Tap Durations"
 
 /* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_CLICKPAD "Synaptics ClickPad"
+
+/* 8 bit (BOOL) */
 #define SYNAPTICS_PROP_TAP_FAST "Synaptics Tap FastTap"
 
 /* 32 bit */
@@ -158,6 +161,9 @@
 /* 32 bit, 4 values, left, right, top, bottom */
 #define SYNAPTICS_PROP_AREA "Synaptics Area"
 
+/* 32 bit, 4 values, left, right, top, buttom */
+#define SYNAPTICS_PROP_SOFTBUTTON_AREAS "Synaptics Soft Button Areas"
+
 /* 32 Bit Integer, 2 values, horizontal hysteresis, vertical hysteresis */
 #define SYNAPTICS_PROP_NOISE_CANCELLATION "Synaptics Noise Cancellation"
 
Index: xserver-xorg-input-synaptics/man/synaptics.man
===================================================================
--- xserver-xorg-input-synaptics.orig/man/synaptics.man	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/man/synaptics.man	2012-03-02 11:50:06.235780000 -0800
@@ -143,6 +143,12 @@ Maximum time (in milliseconds) for detec
 The duration of the mouse click generated by tapping. Property: "Synaptics Tap
 Durations"
 .TP 7
+.BI "Option \*qClickPad\*q \*q" boolean \*q
+Whether the device is a click pad. A click pad device has button(s) integrated
+into the touchpad surface. The user must press downward on the touchpad in order
+to generated a button press. This property may be set automatically if a click
+pad device is detected at initialization time. Property: "Synaptics ClickPad"
+.TP 7
 .BI "Option \*qFastTaps\*q \*q" boolean \*q
 Makes the driver react faster to a single tap, but also makes double
 clicks caused by double tapping slower. Property: "Synaptics Tap FastTap"
@@ -524,6 +530,20 @@ AreaBottomEdge option to any integer val
 server (version 1.9 and later), the edge may be specified in percent of
 the total height of the touchpad. Property: "Synaptics Area"
 .
+.TP
+.BI "Option \*qSoftButtonAreas\*q \*q" "RBL RBR RBT RBB MBL MBR MBT MBB" \*q
+Enable soft button click area support on ClickPad devices. The first four
+parameters define the area of the right button, and the second four parameters
+define the area of the middle button. The areas are defined by the left, right,
+top, and bottom edges as sequential values of the property. If any edge is set
+to 0, the button is assumed to extend to infinity in the given direction.
+.
+When the user performs a click within the defined soft button areas, the right
+or middle click action is performed.
+.
+The use of soft button areas is disabled by setting all the values for the area
+to 0. Property: "Synaptics Soft Button Areas"
+.
 
 .SH CONFIGURATION DETAILS
 .SS Area handling
@@ -797,6 +817,10 @@ Properties supported:
 duration of a single click.
 
 .TP 7
+.BI "Synaptics ClickPad"
+8 bit (Bool).
+
+.TP 7
 .BI "Synaptics Tap FastTap"
 8 bit (BOOL).
 
@@ -933,6 +957,14 @@ default.
 32 bit, 4 values, left, right, top, bottom. 0 disables an element.
 
 .TP 7
+.BI "Synaptics Soft Button Areas"
+The Right and middle soft button areas are used to support right and middle
+click actions on a ClickPad device. Providing 0 for all values of a given button
+disables the button area.
+
+32 bit, 8 values, RBL, RBR, RBT, RBB, MBL, MBR, MBT, MBB.
+
+.TP 7
 .BI "Synaptics Capabilities"
 This read-only property expresses the physical capability of the touchpad,
 most notably whether the touchpad hardware supports multi-finger tapping and
Index: xserver-xorg-input-synaptics/src/eventcomm.c
===================================================================
--- xserver-xorg-input-synaptics.orig/src/eventcomm.c	2012-03-02 11:50:00.207780002 -0800
+++ xserver-xorg-input-synaptics/src/eventcomm.c	2012-03-02 11:50:06.235780000 -0800
@@ -526,6 +526,18 @@ SynapticsReadEvent(InputInfoPtr pInfo, s
     return rc;
 }
 
+static Bool
+EventTouchSlotPreviouslyOpen(SynapticsPrivate *priv, int slot)
+{
+    int i;
+
+    for (i = 0; i < priv->num_active_touches; i++)
+        if (priv->open_slots[i] == slot)
+            return TRUE;
+
+    return FALSE;
+}
+
 static void
 EventProcessTouchEvent(InputInfoPtr pInfo, struct SynapticsHwState *hw,
                        struct input_event *ev)
@@ -566,8 +578,20 @@ EventProcessTouchEvent(InputInfoPtr pInf
             int map = proto_data->axis_map[ev->code - ABS_MT_TOUCH_MAJOR];
             valuator_mask_set(hw->mt_mask[slot_index], map, ev->value);
             if (slot_index >= 0)
-                valuator_mask_set(proto_data->last_mt_vals[slot_index], map,
-                                  ev->value);
+            {
+                ValuatorMask *mask = proto_data->last_mt_vals[slot_index];
+                int last_val = valuator_mask_get(mask, map);
+
+                if (EventTouchSlotPreviouslyOpen(priv, slot_index))
+                {
+                    if (ev->code == ABS_MT_POSITION_X)
+                        hw->cumulative_dx += ev->value - last_val;
+                    else if (ev->code == ABS_MT_POSITION_Y)
+                        hw->cumulative_dy += ev->value - last_val;
+                }
+
+                valuator_mask_set(mask, map, ev->value);
+            }
         }
     }
 #endif
@@ -609,6 +633,13 @@ EventReadHwState(InputInfoPtr pInfo,
 
     SynapticsResetTouchHwState(hw);
 
+    /* Reset cumulative values if buttons were not previously pressed */
+    if (!hw->left && !hw->right && !hw->middle)
+    {
+        hw->cumulative_dx = hw->x;
+        hw->cumulative_dy = hw->y;
+    }
+
     while (SynapticsReadEvent(pInfo, &ev)) {
 	switch (ev.type) {
 	case EV_SYN:
@@ -713,6 +744,7 @@ static void
 event_query_touch(InputInfoPtr pInfo)
 {
     SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
     struct eventcomm_proto_data *proto_data = priv->proto_data;
     struct mtdev *mtdev;
     int i;
@@ -727,7 +759,13 @@ event_query_touch(InputInfoPtr pInfo)
     {
         xf86IDrvMsg(pInfo, X_INFO,
                     "ignoring touch events for semi-multitouch device\n");
-        return;
+        priv->has_semi_mt = TRUE;
+    }
+
+    if (rc >= 0 && BitIsOn(&prop, INPUT_PROP_BUTTONPAD))
+    {
+        xf86IDrvMsg(pInfo, X_INFO, "found clickpad property\n");
+        para->clickpad = TRUE;
     }
 
     mtdev = mtdev_new_open(pInfo->fd);
Index: xserver-xorg-input-synaptics/src/properties.c
===================================================================
--- xserver-xorg-input-synaptics.orig/src/properties.c	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/src/properties.c	2012-03-02 11:50:06.239780000 -0800
@@ -58,6 +58,7 @@ Atom prop_finger                = 0;
 Atom prop_tap_time              = 0;
 Atom prop_tap_move              = 0;
 Atom prop_tap_durations         = 0;
+Atom prop_clickpad              = 0;
 Atom prop_tap_fast              = 0;
 Atom prop_middle_timeout        = 0;
 Atom prop_twofinger_pressure    = 0;
@@ -92,6 +93,7 @@ Atom prop_gestures              = 0;
 Atom prop_capabilities          = 0;
 Atom prop_resolution            = 0;
 Atom prop_area                  = 0;
+Atom prop_softbutton_areas      = 0;
 Atom prop_noise_cancellation    = 0;
 Atom prop_product_id            = 0;
 Atom prop_device_node           = 0;
@@ -190,6 +192,8 @@ InitDeviceProperties(InputInfoPtr pInfo)
     values[2] = para->click_time;
 
     prop_tap_durations = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_DURATIONS, 32, 3, values);
+    prop_clickpad = InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICKPAD, 8, 1,
+                             &para->clickpad);
     prop_tap_fast = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_FAST, 8, 1, &para->fast_taps);
     prop_middle_timeout = InitAtom(pInfo->dev, SYNAPTICS_PROP_MIDDLE_TIMEOUT,
                                    32, 1, &para->emulate_mid_button_time);
@@ -298,6 +302,16 @@ InitDeviceProperties(InputInfoPtr pInfo)
     values[3] = para->area_bottom_edge;
     prop_area = InitAtom(pInfo->dev, SYNAPTICS_PROP_AREA, 32, 4, values);
 
+    values[0] = para->softbutton_areas[0][0];
+    values[1] = para->softbutton_areas[0][1];
+    values[2] = para->softbutton_areas[0][2];
+    values[3] = para->softbutton_areas[0][3];
+    values[4] = para->softbutton_areas[1][0];
+    values[5] = para->softbutton_areas[1][1];
+    values[6] = para->softbutton_areas[1][2];
+    values[7] = para->softbutton_areas[1][3];
+    prop_softbutton_areas = InitAtom(pInfo->dev, SYNAPTICS_PROP_SOFTBUTTON_AREAS, 32, 8, values);
+
     values[0] = para->hyst_x;
     values[1] = para->hyst_y;
     prop_noise_cancellation = InitAtom(pInfo->dev,
@@ -393,7 +407,25 @@ SetProperty(DeviceIntPtr dev, Atom prope
         para->single_tap_timeout = timeouts[0];
         para->tap_time_2         = timeouts[1];
         para->click_time         = timeouts[2];
+    } else if (property == prop_clickpad) {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->clickpad = *(BOOL*)prop->data;
+
+        /* ClickPad support conflicts with click action support. Reset click
+         * actions. The user can override afterwards if they really want. */
+        if (para->clickpad)
+        {
+            CARD8 values[3] = {};
+
+            para->click_action[F1_CLICK1] = 0;
+            para->click_action[F2_CLICK1] = 0;
+            para->click_action[F3_CLICK1] = 0;
 
+            XIChangeDeviceProperty(dev, prop_clickaction, XA_INTEGER, 8,
+                                   PropModeReplace, 3, values, TRUE);
+        }
     } else if (property == prop_tap_fast)
     {
         if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
@@ -711,6 +743,19 @@ SetProperty(DeviceIntPtr dev, Atom prope
         para->area_right_edge  = area[1];
         para->area_top_edge    = area[2];
         para->area_bottom_edge = area[3];
+    } else if (property == prop_softbutton_areas)
+    {
+        int *areas;
+
+        if (prop->size != 8 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        areas = (int*)prop->data;
+        if (!SynapticsIsSoftButtonAreasValid(areas))
+            return BadValue;
+
+        memcpy(para->softbutton_areas[0], areas, 4 * sizeof(int));
+        memcpy(para->softbutton_areas[1], areas + 4, 4 * sizeof(int));
     } else if (property == prop_noise_cancellation) {
         INT32 *hyst;
         if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
Index: xserver-xorg-input-synaptics/src/synaptics.c
===================================================================
--- xserver-xorg-input-synaptics.orig/src/synaptics.c	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/src/synaptics.c	2012-03-02 11:50:19.495780001 -0800
@@ -410,6 +410,120 @@ static int set_percent_option(pointer op
     return result;
 }
 
+Bool SynapticsIsSoftButtonAreasValid(int *values)
+{
+    Bool right_disabled = FALSE;
+    Bool middle_disabled = FALSE;
+
+    /* Check right button area */
+    if ((((values[0] != 0) && (values[1] != 0)) && (values[0] > values[1])) ||
+        (((values[2] != 0) && (values[3] != 0)) && (values[2] > values[3])))
+        return FALSE;
+
+    /* Check middle button area */
+    if ((((values[4] != 0) && (values[5] != 0)) && (values[4] > values[5])) ||
+        (((values[6] != 0) && (values[7] != 0)) && (values[6] > values[7])))
+        return FALSE;
+
+    if (values[0] == 0 && values[1] == 0 && values[2] == 0 && values[3] == 0)
+        right_disabled = TRUE;
+
+    if (values[4] == 0 && values[5] == 0 && values[6] == 0 && values[7] == 0)
+        middle_disabled = TRUE;
+
+    /* Check for overlapping button areas */
+    if (!right_disabled && !middle_disabled)
+    {
+        int right_left = values[0] ? values[0] : INT_MIN;
+        int right_right = values[1] ? values[1] : INT_MAX;
+        int right_top = values[2] ? values[2] : INT_MIN;
+        int right_bottom = values[3] ? values[3] : INT_MAX;
+        int middle_left = values[4] ? values[4] : INT_MIN;
+        int middle_right = values[5] ? values[5] : INT_MAX;
+        int middle_top = values[6] ? values[6] : INT_MIN;
+        int middle_bottom = values[7] ? values[7] : INT_MAX;
+
+        /* If areas overlap in the Y axis */
+        if ((right_bottom <= middle_bottom && right_bottom >= middle_top) ||
+            (right_top <= middle_bottom && right_top >= middle_top))
+        {
+            /* Check for identical right and left edges */
+            if (right_left == middle_left || right_right == middle_right)
+                return FALSE;
+
+            /* Check for overlapping left edges */
+            if ((right_left < middle_left && right_right >= middle_left) ||
+                (middle_left < right_left && middle_right >= right_left))
+                return FALSE;
+
+            /* Check for overlapping right edges */
+            if ((right_right > middle_right && right_left <= middle_right) ||
+                (middle_right > right_right && middle_left <= right_right))
+                return FALSE;
+        }
+
+        /* If areas overlap in the X axis */
+        if ((right_left >= middle_left && right_left <= middle_right) ||
+            (right_right >= middle_left && right_right <= middle_right))
+        {
+            /* Check for overlapping top edges */
+            if ((right_top < middle_top && right_bottom >= middle_top) ||
+                (middle_top < right_top && middle_bottom >= right_top))
+                return FALSE;
+
+            /* Check for overlapping bottom edges */
+            if ((right_bottom > middle_bottom && right_top <= middle_bottom) ||
+                (middle_bottom > right_bottom && middle_top <= right_bottom))
+                return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+static void set_softbutton_areas_option(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = pInfo->private;
+    SynapticsParameters *pars = &priv->synpara;
+    int values[8];
+    char *option_string;
+    char *next_num;
+    char *end_str;
+    int i;
+
+    option_string = xf86CheckStrOption(pInfo->options, "SoftButtonAreas", NULL);
+    if (!option_string)
+        return;
+
+    next_num = option_string;
+
+    for (i = 0; i < 8 && *next_num != '\0'; i++)
+    {
+        long int value = strtol(next_num, &end_str, 0);
+        if (value > INT_MAX || value < -INT_MAX)
+            goto fail;
+
+        values[i] = value;
+
+        if (next_num != end_str)
+            next_num = end_str;
+        else
+            goto fail;
+    }
+
+    if (i < 8 || *next_num != '\0' || !SynapticsIsSoftButtonAreasValid(values))
+        goto fail;
+
+    memcpy(pars->softbutton_areas[0], values, 4 * sizeof(int));
+    memcpy(pars->softbutton_areas[1], values + 4, 4 * sizeof(int));
+
+    return;
+
+fail:
+    xf86IDrvMsg(pInfo, X_ERROR, "invalid SoftButtonAreas value '%s', keeping defaults\n",
+                option_string);
+}
+
 static void set_default_parameters(InputInfoPtr pInfo)
 {
     SynapticsPrivate *priv = pInfo->private; /* read-only */
@@ -428,7 +542,7 @@ static void set_default_parameters(Input
     int pressureMotionMinZ, pressureMotionMaxZ;		/* pressure */
     int palmMinWidth, palmMinZ;				/* pressure */
     int tapButton1, tapButton2, tapButton3;
-    int clickFinger1, clickFinger2, clickFinger3;
+    int clickFinger1 = 0, clickFinger2 = 0, clickFinger3 = 0;
     Bool vertEdgeScroll, horizEdgeScroll;
     Bool vertTwoFingerScroll, horizTwoFingerScroll;
     int horizResolution = 1;
@@ -488,6 +602,11 @@ static void set_default_parameters(Input
     palmMinWidth = priv->minw + range * (10.0/16);
     emulateTwoFingerMinW = priv->minw + range * (7.0/16);
 
+    /* Clickpad conflicts with click actions, disable by default unless there
+     * is a physical right button. */
+    if (pars->clickpad && !priv->has_right)
+        pars->clickpad = 0;
+
     /* Enable tap */
     tapButton1 = 1;
     tapButton2 = 2;
@@ -495,9 +614,12 @@ static void set_default_parameters(Input
 
     /* Enable multifinger-click if only have one physical button,
        otherwise clickFinger is always button 1. */
-    clickFinger1 = 1;
-    clickFinger2 = (priv->has_right || priv->has_middle) ? 1 : 3;
-    clickFinger3 = 0; /* Disabled by default so three-touch gestures work */
+    if (!pars->clickpad)
+    {
+        clickFinger1 = 1;
+        clickFinger2 = (priv->has_right || priv->has_middle) ? 1 : 3;
+        clickFinger3 = 0; /* Disabled by default so three-touch gestures work */
+    }
 
     /* Enable vert edge scroll */
     vertEdgeScroll = TRUE;
@@ -534,6 +656,7 @@ static void set_default_parameters(Input
     pars->tap_move = xf86SetIntOption(opts, "MaxTapMove", tapMove);
     pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
     pars->click_time = xf86SetIntOption(opts, "ClickTime", 100);
+    pars->clickpad = xf86SetIntOption(opts, "ClickPad", pars->clickpad); /* Probed */
     pars->fast_taps = xf86SetBoolOption(opts, "FastTaps", FALSE);
     pars->emulate_mid_button_time = xf86SetIntOption(opts, "EmulateMidButtonTime", 75);
     pars->emulate_twofinger_z = xf86SetIntOption(opts, "EmulateTwoFingerMinZ", emulateTwoFingerMinZ);
@@ -602,6 +725,8 @@ static void set_default_parameters(Input
 	pars->bottom_edge = tmp;
 	xf86IDrvMsg(pInfo, X_WARNING, "TopEdge is bigger than BottomEdge. Fixing.\n");
     }
+
+    set_softbutton_areas_option(pInfo);
 }
 
 #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 14
@@ -1355,6 +1480,60 @@ is_inside_active_area(SynapticsPrivate *
     return inside_area;
 }
 
+static Bool
+is_inside_rightbutton_area(SynapticsParameters *para, int x, int y)
+{
+    Bool inside_area = TRUE;
+
+    if (para->softbutton_areas[0][0] == 0 &&
+        para->softbutton_areas[0][1] == 0 &&
+        para->softbutton_areas[0][2] == 0 &&
+        para->softbutton_areas[0][3] == 0)
+        return FALSE;
+
+    if (para->softbutton_areas[0][0] &&
+        x < para->softbutton_areas[0][0])
+	inside_area = FALSE;
+    else if (para->softbutton_areas[0][1] &&
+             x > para->softbutton_areas[0][1])
+	inside_area = FALSE;
+    else if (para->softbutton_areas[0][2] &&
+             y < para->softbutton_areas[0][2])
+	inside_area = FALSE;
+    else if (para->softbutton_areas[0][3] &&
+             y > para->softbutton_areas[0][3])
+	inside_area = FALSE;
+
+    return inside_area;
+}
+
+static Bool
+is_inside_middlebutton_area(SynapticsParameters *para, int x, int y)
+{
+    Bool inside_area = TRUE;
+
+    if (para->softbutton_areas[1][0] == 0 &&
+        para->softbutton_areas[1][1] == 0 &&
+        para->softbutton_areas[1][2] == 0 &&
+        para->softbutton_areas[1][3] == 0)
+        return FALSE;
+
+    if (para->softbutton_areas[1][0] &&
+        x < para->softbutton_areas[1][0])
+	inside_area = FALSE;
+    else if (para->softbutton_areas[1][1] &&
+             x > para->softbutton_areas[1][1])
+	inside_area = FALSE;
+    else if (para->softbutton_areas[1][2] &&
+             y < para->softbutton_areas[1][2])
+	inside_area = FALSE;
+    else if (para->softbutton_areas[1][3] &&
+             y > para->softbutton_areas[1][3])
+	inside_area = FALSE;
+
+    return inside_area;
+}
+
 static CARD32
 timerFunc(OsTimerPtr timer, CARD32 now, pointer arg)
 {
@@ -1411,6 +1590,14 @@ ReadInput(InputInfoPtr pInfo)
     SynapticsResetTouchHwState(hw);
 
     while (SynapticsGetHwState(pInfo, priv, hw)) {
+	/* Semi-mt device touch slots do not track touches. When there is a
+	 * change in the number of touches, we must disregard the temporary
+	 * motion changes. */
+	if (priv->has_semi_mt && hw->numFingers != priv->hwState->numFingers) {
+	    hw->cumulative_dx = priv->hwState->cumulative_dx;
+	    hw->cumulative_dy = priv->hwState->cumulative_dy;
+	}
+
 	SynapticsCopyHwState(priv->hwState, hw);
 	delay = HandleState(pInfo, hw, hw->millis, FALSE);
 	newDelay = TRUE;
@@ -1692,7 +1879,7 @@ HandleTapProcessing(SynapticsPrivate *pr
 		    Bool inside_active_area)
 {
     SynapticsParameters *para = &priv->synpara;
-    Bool touch, release, is_timeout, move;
+    Bool touch, release, is_timeout, move, press;
     int timeleft, timeout;
     edge_type edge;
     int delay = 1000000000;
@@ -1706,6 +1893,7 @@ HandleTapProcessing(SynapticsPrivate *pr
 	     (priv->tap_max_fingers <= ((priv->horiz_scroll_twofinger_on || priv->vert_scroll_twofinger_on)? 2 : 1)) &&
 	     ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
 	     (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
+    press = (hw->left || hw->right || hw->middle);
 
     if (touch) {
 	priv->touch_on.x = hw->x;
@@ -1728,6 +1916,10 @@ HandleTapProcessing(SynapticsPrivate *pr
 	    SetTapState(priv, TS_1, now);
 	break;
     case TS_1:
+	if (para->clickpad && press) {
+	    SetTapState(priv, TS_CLICKPAD_MOVE, now);
+	    goto restart;
+	}
 	if (move) {
 	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
 	    SetTapState(priv, TS_MOVE, now);
@@ -1751,6 +1943,10 @@ HandleTapProcessing(SynapticsPrivate *pr
 	}
 	break;
     case TS_MOVE:
+	if (para->clickpad && press) {
+	    SetTapState(priv, TS_CLICKPAD_MOVE, now);
+	    goto restart;
+	}
 	if (move && priv->moving_state == MS_TRACKSTICK) {
 	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
 	}
@@ -1805,6 +2001,10 @@ HandleTapProcessing(SynapticsPrivate *pr
 	}
 	break;
     case TS_DRAG:
+	if (para->clickpad && press) {
+	    SetTapState(priv, TS_CLICKPAD_MOVE, now);
+	    goto restart;
+	}
 	if (move)
 	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
 	if (release) {
@@ -1833,6 +2033,23 @@ HandleTapProcessing(SynapticsPrivate *pr
 	    SetTapState(priv, TS_START, now);
 	}
 	break;
+    case TS_CLICKPAD_MOVE:
+	/* Disable scrolling once a button is pressed on a clickpad */
+	priv->vert_scroll_edge_on = FALSE;
+	priv->horiz_scroll_edge_on = FALSE;
+	priv->vert_scroll_twofinger_on = FALSE;
+	priv->horiz_scroll_twofinger_on = FALSE;
+
+        /* Assume one touch is only for holding the clickpad button down */
+	if (hw->numFingers > 1)
+	    hw->numFingers--;
+	SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+	if (!press) {
+	    SetMovingState(priv, MS_FALSE, now);
+	    SetTapState(priv, TS_MOVE, now);
+	    priv->count_packet_finger = 0;
+	}
+	break;
     }
 
     timeout = GetTimeOut(priv);
@@ -1955,9 +2172,8 @@ get_delta(SynapticsPrivate *priv, const
     int x_edge_speed = 0;
     int y_edge_speed = 0;
 
-    /* HIST is full enough: priv->count_packet_finger > 3 */
-    *dx = estimate_delta(hw->x, HIST(0).x, HIST(1).x, HIST(2).x);
-    *dy = estimate_delta(hw->y, HIST(0).y, HIST(1).y, HIST(2).y);
+    *dx = hw->x - HIST(0).x;
+    *dy = hw->y - HIST(0).y;
 
     if ((priv->tap_state == TS_DRAG) || para->edge_motion_use_always)
         get_edge_speed(priv, hw, edge, &x_edge_speed, &y_edge_speed);
@@ -2026,7 +2242,7 @@ ComputeDeltas(SynapticsPrivate *priv, co
      * POLL_MS declaration. */
     delay = MIN(delay, POLL_MS);
 
-    if (priv->count_packet_finger <= 3) /* min. 3 packets, see get_delta() */
+    if (priv->count_packet_finger <= 1)
         goto out; /* skip the lot */
 
     if (priv->moving_state == MS_TRACKSTICK)
@@ -2468,6 +2684,22 @@ update_hw_button_state(const InputInfoPt
     /* 3rd button emulation */
     hw->middle |= HandleMidButtonEmulation(priv, hw, now, delay);
 
+    /* If this is a clickpad and the user clicks in a soft button area, press
+     * the soft button instead. */
+    if (para->clickpad && hw->left && !hw->right && !hw->middle)
+    {
+        if (is_inside_rightbutton_area(para, hw->x, hw->y))
+        {
+            hw->left = 0;
+            hw->right = 1;
+        }
+        else if (is_inside_middlebutton_area(para, hw->x, hw->y))
+        {
+            hw->left = 0;
+            hw->middle = 1;
+        }
+    }
+
     /* Fingers emulate other buttons */
     if(hw->left && hw->numFingers >= 1){
         handle_clickfinger(para, hw);
@@ -2659,6 +2891,9 @@ HandleTouches(InputInfoPtr pInfo, struct
             new_active_touches--;
     }
 
+    if (priv->has_semi_mt)
+        goto out;
+
     if (priv->num_active_touches < min_touches &&
         new_active_touches < min_touches)
     {
@@ -2752,6 +2987,14 @@ HandleState(InputInfoPtr pInfo, struct S
 	return delay;
     }
 
+    /* If a physical button is pressed on a clickpad, use cumulative relative
+     * touch movements for motion */
+    if (para->clickpad && (hw->left || hw->right || hw->middle))
+    {
+        hw->x = hw->cumulative_dx;
+        hw->y = hw->cumulative_dy;
+    }
+
     /* apply hysteresis before doing anything serious. This cancels
      * out a lot of noise which might surface in strange phenomena
      * like flicker in scrolling or noise motion. */
Index: xserver-xorg-input-synaptics/src/synapticsstr.h
===================================================================
--- xserver-xorg-input-synaptics.orig/src/synapticsstr.h	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/src/synapticsstr.h	2012-03-02 11:50:06.239780000 -0800
@@ -99,7 +99,8 @@ enum TapState {
     TS_3,			/* After second touch */
     TS_DRAG,			/* Pointer drag enabled */
     TS_4,			/* After release when "locked drags" enabled */
-    TS_5			/* After touch when "locked drags" enabled */
+    TS_5,			/* After touch when "locked drags" enabled */
+    TS_CLICKPAD_MOVE,		/* After left button press on a clickpad */
 };
 
 enum TapButtonState {
@@ -125,6 +126,7 @@ typedef struct _SynapticsParameters
     int single_tap_timeout;		    /* timeout to recognize a single tap */
     int tap_time_2;			    /* max. tapping time for double taps */
     int click_time;			    /* The duration of a single click */
+    Bool clickpad;                          /* Device is a has integrated buttons */
     Bool fast_taps;			    /* Faster reaction to single taps */
     int emulate_mid_button_time;	    /* Max time between left and right button presses to
 					       emulate a middle button press. */
@@ -179,6 +181,7 @@ typedef struct _SynapticsParameters
     unsigned int resolution_horiz;          /* horizontal resolution of touchpad in units/mm */
     unsigned int resolution_vert;           /* vertical resolution of touchpad in units/mm */
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
+    int softbutton_areas[2][4];             /* soft button area coordinates, 0 => right, 1 => middle button */
     int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
 } SynapticsParameters;
 
@@ -266,6 +269,7 @@ typedef struct _SynapticsPrivateRec
     Bool has_pressure;			/* device reports pressure */
     Bool has_width;			/* device reports finger width */
     Bool has_scrollbuttons;		/* device has physical scrollbuttons */
+    Bool has_semi_mt;			/* device is only semi-multitouch capable */
 
     enum TouchpadModel model;		/* The detected model */
     unsigned short id_vendor;		/* vendor id */
Index: xserver-xorg-input-synaptics/src/synproto.c
===================================================================
--- xserver-xorg-input-synaptics.orig/src/synproto.c	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/src/synproto.c	2012-03-02 11:50:06.239780000 -0800
@@ -120,6 +120,8 @@ SynapticsCopyHwState(struct SynapticsHwS
     dst->x = src->x;
     dst->y = src->y;
     dst->z = src->z;
+    dst->cumulative_dx = src->cumulative_dx;
+    dst->cumulative_dy = src->cumulative_dy;
     dst->numFingers = src->numFingers;
     dst->fingerWidth = src->fingerWidth;
     dst->left = src->left;
Index: xserver-xorg-input-synaptics/src/synproto.h
===================================================================
--- xserver-xorg-input-synaptics.orig/src/synproto.h	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/src/synproto.h	2012-03-02 11:50:06.239780000 -0800
@@ -53,6 +53,8 @@ struct SynapticsHwState {
     int x;			/* X position of finger */
     int y;			/* Y position of finger */
     int z;			/* Finger pressure */
+    int cumulative_dx;		/* Cumulative delta X for clickpad dragging */
+    int cumulative_dy;		/* Cumulative delta Y for clickpad dragging */
     int numFingers;
     int fingerWidth;
 
@@ -115,4 +117,6 @@ extern void SynapticsCopyHwState(struct
                                  const struct SynapticsHwState *src);
 extern void SynapticsResetTouchHwState(struct SynapticsHwState *hw);
 
+extern Bool SynapticsIsSoftButtonAreasValid(int *values);
+
 #endif /* _SYNPROTO_H_ */
Index: xserver-xorg-input-synaptics/test/fake-symbols.c
===================================================================
--- xserver-xorg-input-synaptics.orig/test/fake-symbols.c	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/test/fake-symbols.c	2012-03-02 11:50:06.239780000 -0800
@@ -461,6 +461,11 @@ _X_EXPORT void valuator_mask_free(Valuat
 {
 }
 
+_X_EXPORT int valuator_mask_get(const ValuatorMask *mask, int valuator)
+{
+    return 0;
+}
+
 _X_EXPORT void valuator_mask_set(ValuatorMask *mask, int valuator, int data)
 {
 }
Index: xserver-xorg-input-synaptics/tools/synclient.c
===================================================================
--- xserver-xorg-input-synaptics.orig/tools/synclient.c	2012-03-02 11:50:00.000000000 -0800
+++ xserver-xorg-input-synaptics/tools/synclient.c	2012-03-02 11:50:06.243780000 -0800
@@ -38,6 +38,7 @@
 #include <string.h>
 #include <stddef.h>
 #include <math.h>
+#include <limits.h>
 
 #include <X11/Xdefs.h>
 #include <X11/Xatom.h>
@@ -144,6 +145,15 @@ static struct Parameter params[] = {
     {"AreaRightEdge",         PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	1},
     {"AreaTopEdge",           PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	2},
     {"AreaBottomEdge",        PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	3},
+    {"ClickPad",              PT_BOOL,   0, 1,     SYNAPTICS_PROP_CLICKPAD,	8,	0},
+    {"RightButtonAreaLeft",   PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	0},
+    {"RightButtonAreaRight",  PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	1},
+    {"RightButtonAreaTop",    PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	2},
+    {"RightButtonAreaBottom", PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	3},
+    {"MiddleButtonAreaLeft",  PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	4},
+    {"MiddleButtonAreaRight", PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	5},
+    {"MiddleButtonAreaTop",   PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	6},
+    {"MiddleButtonAreaBottom", PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	7},
     { NULL, 0, 0, 0, 0 }
 };
 
