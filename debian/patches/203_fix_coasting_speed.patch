Origin: http://patchwork.freedesktop.org/patch/9653/
From: =?UTF-8?q?Pierre=20Lul=C3=A9?= <pierre@lule.fr>
Date: Tue, 27 Mar 2012 22:13:30 +0000
Subject: [PATCH] Fix coasting speed

Oops, left a typo in previous patch. Here's the correction.

Fixes a bug introduced in commit 2603ad69b997c999404ecc441e0d64ea2cc22018 (Use
the scroll distances as increment for scrolling valuator axes)

Since this commit, scroll distance was set with SetScrollValuator function but
it was still used as a divisor to calculate coasting, thus making coasting too
slow. (at least on my computer)

Deleting the divisor and adding it as a multiplier for the CoastingFriction
fixes the issue.

A report of the same bug : https://bugs.archlinux.org/task/28955
---
 src/synaptics.c |   27 ++++++++++++---------------
 1 file changed, 12 insertions(+), 15 deletions(-)

diff --git a/src/synaptics.c b/src/synaptics.c
index 99b5085..379c8c4 100644
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -2330,39 +2330,36 @@ start_coasting(SynapticsPrivate *priv, struct SynapticsHwState *hw,
 	double pkt_time = HIST_DELTA(0, 3, millis) / 1000.0;
 	if (vert && !circ) {
 	    double dy = estimate_delta(HIST(0).y, HIST(1).y, HIST(2).y, HIST(3).y);
-	    int sdelta = para->scroll_dist_vert;
-	    if (pkt_time > 0 && sdelta > 0) {
-		double scrolls_per_sec = dy / pkt_time / sdelta;
+	    if (pkt_time > 0) {
+		double scrolls_per_sec = dy / pkt_time;
 		if (fabs(scrolls_per_sec) >= para->coasting_speed) {
 		    priv->scroll.coast_speed_y = scrolls_per_sec;
-		    priv->scroll.coast_delta_y = (hw->y - priv->scroll.last_y) / (double)sdelta;
+		    priv->scroll.coast_delta_y = (hw->y - priv->scroll.last_y);
 		}
 	    }
 	}
 	if (horiz && !circ){
 	    double dx = estimate_delta(HIST(0).x, HIST(1).x, HIST(2).x, HIST(3).x);
-	    int sdelta = para->scroll_dist_horiz;
-	    if (pkt_time > 0 && sdelta > 0) {
-		double scrolls_per_sec = dx / pkt_time / sdelta;
+	    if (pkt_time > 0) {
+		double scrolls_per_sec = dx / pkt_time;
 		if (fabs(scrolls_per_sec) >= para->coasting_speed) {
 		    priv->scroll.coast_speed_x = scrolls_per_sec;
-		    priv->scroll.coast_delta_x = (hw->x - priv->scroll.last_x) / (double)sdelta;
+		    priv->scroll.coast_delta_x = (hw->x - priv->scroll.last_x);
 		}
 	    }
 	}
 	if (circ) {
 	    double da = estimate_delta_circ(priv);
-	    double sdelta = para->scroll_dist_circ;
-	    if (pkt_time > 0 && sdelta > 0) {
-	        double scrolls_per_sec = da / pkt_time / sdelta;
+	    if (pkt_time > 0) {
+	        double scrolls_per_sec = da / pkt_time;
 	        if (fabs(scrolls_per_sec) >= para->coasting_speed) {
 	            if (vert) {
 	                priv->scroll.coast_speed_y = scrolls_per_sec;
-	                priv->scroll.coast_delta_y = diffa(priv->scroll.last_a, angle(priv, hw->x, hw->y)) / sdelta;
+	                priv->scroll.coast_delta_y = diffa(priv->scroll.last_a, angle(priv, hw->x, hw->y));
 	            }
 	            else if (horiz) {
 	                priv->scroll.coast_speed_x = scrolls_per_sec;
-	                priv->scroll.coast_delta_x = diffa(priv->scroll.last_a, angle(priv, hw->x, hw->y)) / sdelta;
+	                priv->scroll.coast_delta_x = diffa(priv->scroll.last_a, angle(priv, hw->x, hw->y));
 	            }
 	        }
 	    }
@@ -2588,7 +2585,7 @@ HandleScrolling(SynapticsPrivate *priv, struct SynapticsHwState *hw,
 
     if (priv->scroll.coast_speed_y) {
 	double dtime = (hw->millis - priv->scroll.last_millis) / 1000.0;
-	double ddy = para->coasting_friction * dtime;
+	double ddy = para->coasting_friction * dtime * para->scroll_dist_vert;
 	priv->scroll.delta_y += priv->scroll.coast_speed_y * dtime;
 	delay = MIN(delay, POLL_MS);
 	if (abs(priv->scroll.coast_speed_y) < ddy) {
@@ -2601,7 +2598,7 @@ HandleScrolling(SynapticsPrivate *priv, struct SynapticsHwState *hw,
 
     if (priv->scroll.coast_speed_x) {
 	double dtime = (hw->millis - priv->scroll.last_millis) / 1000.0;
-	double ddx = para->coasting_friction * dtime;
+	double ddx = para->coasting_friction * dtime * para->scroll_dist_horiz;
 	priv->scroll.delta_x += priv->scroll.coast_speed_x * dtime;
 	delay = MIN(delay, POLL_MS);
 	if (abs(priv->scroll.coast_speed_x) < ddx) {
-- 
1.7.9.5

